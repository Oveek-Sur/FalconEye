#!/usr/bin/env python3
"""FalconEye Vulnerability Scanning Module - Specialized Nmap NSE Scanning (STANDALONE)"""
import os
import re
import shutil
import subprocess
import json
import sys
import time
from typing import Dict, List, Optional, Callable
from datetime import datetime
from collections import defaultdict

# =======================================================
# --- REQUIRED MODULE ATTRIBUTES FOR FALCONEYE MENU ---
# =======================================================
name = "Vulnerability Scan (NSE)"
description = "Runs Nmap's 'vuln' category scripts and checks Exploit Intelligence."

# =======================================================
# --- STANDALONE HELPER FUNCTIONS ---
# =======================================================

class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def print_colored(text: str, color=Colors.ENDC):
    """Print colored text to terminal"""
    print(f"{color}{text}{Colors.ENDC}")

def get_user_input(prompt: str) -> str:
    """Get sanitized user input"""
    try:
        return input(prompt).strip()
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        return ""

def check_root_privileges():
    try:
        return os.geteuid() == 0
    except AttributeError:
        return False

def check_searchsploit() -> bool:
    """Verify Searchsploit installation."""
    return shutil.which("searchsploit") is not None

def get_scan_output_dir(target: str, module_name: str) -> str:
    """Placeholder for directory creation (output saving is disabled per user request)."""
    # NOTE: This function remains for structure but should not be used to save output.
    return ""

def draw_separator(char="â”€", width: int = 105):
    """Draw a horizontal separator line"""
    print(char * width)

def run_command_with_output(cmd: List[str], timeout: int = 1800) -> Dict:
    """Executes command and streams/captures output."""
    
    if 'nmap' in cmd[0].lower() and os.geteuid() != 0 and 'sudo' not in cmd[0].lower():
        cmd.insert(0, 'sudo')
        print_colored("[WARNING] Adding 'sudo' for proper Nmap execution.", Colors.WARNING)

    print(f"\n[EXEC] {' '.join(cmd)}")
    
    try:
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding='utf-8',
            bufsize=1
        )

        output_lines = []
        
        for line in process.stdout:
            line_strip = line.strip()
            output_lines.append(line_strip)
            if any(keyword in line for keyword in ["Stats:", "Host is up", "Nmap scan report", "Timing:", "Starting Nmap"]):
                print(line_strip) 

        process.wait(timeout=timeout)
        
        for line in process.stdout.readlines():
             output_lines.append(line.strip())
             
        return {
            'returncode': process.returncode,
            'output': '\n'.join(output_lines)
        }
    
    except FileNotFoundError:
        return {'returncode': 127, 'output': f"Error: Command not found or Nmap is not in PATH."}
    except subprocess.TimeoutExpired:
        return {'returncode': -1, 'output': f"Error: Command timed out after {timeout} seconds."}
    except Exception as e:
        return {'returncode': 1, 'output': f"Runtime Error: {e}"}

# =======================================================
# Exploitation Intelligence Functions (Parsers)
# =======================================================

def extract_service_versions(output: str) -> Dict[str, str]:
    """Extracts service name and version from Nmap output for exploit lookup."""
    versions = {}
    # Find lines with port, open state, service, and version
    service_pattern = re.compile(r'^\s*(\d+/\w+)\s+open\s+([\w-]+)\s+(.*?)$', re.MULTILINE | re.IGNORECASE)
    
    matches = service_pattern.findall(output)
    
    for port, service_name, version_string in matches:
        clean_query = f"{service_name} {version_string.split(' ')[0]}"
        versions[port] = clean_query.strip()
        
    return versions

# --- MODIFIED: Returns full list of exploits for detailed report ---
def run_exploit_lookup(service_versions: Dict[str, str]) -> Dict[str, List[Dict]]:
    """Runs searchsploit for each service version and collects detailed results."""
    if not check_searchsploit():
        return {}
        
    exploit_details: Dict[str, List[Dict]] = {}
    
    print_colored("\n--- Running Exploit Intelligence Lookup (Searchsploit) ---", Colors.OKBLUE)
    
    for port, query in service_versions.items():
        if "tcpwrapped" in query.lower() or "unknown" in query.lower() or ("ssh" in query.lower() and "openssh" not in query.lower()):
            continue

        try:
            cmd = ["searchsploit", "--json", query]
            proc = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
            
            json_start = proc.stdout.find('{')
            json_end = proc.stdout.rfind('}')
            
            if json_start != -1 and json_end != -1:
                json_data = proc.stdout[json_start : json_end + 1]
                data = json.loads(json_data)
                
                results_list = []
                for exploit in data.get("RESULTS_EXPLOIT", []):
                    results_list.append({
                        "Title": exploit.get("Title", "N/A"),
                        "Path": exploit.get("Path", "N/A")
                    })
                
                if results_list:
                    exploit_details[port] = results_list
            
        except Exception:
            continue 
            
    return exploit_details

# --- VULN SCAN CORE LOGIC (Parser) ---
def parse_vuln_output(output: str) -> List[Dict]:
    """Parses Nmap raw output to summarize key vulnerabilities (CVSS scores and IDs)."""
    
    summaries = []
    
    # 1. Split the entire output by "PORT/STATE/SERVICE/VERSION" to get individual port blocks
    port_blocks = re.split(r'\n(?=\d+/\w+\s+open)', '\n' + output)

    for block in port_blocks:
        if not block.strip():
            continue
            
        # a. Extract base port/service info from the first line of the block
        header_match = re.search(r'(\d+/\w+)\s+open\s+([^\n]+)', block)
        if not header_match:
            continue
        
        port = header_match.group(1)
        full_service_info = header_match.group(2).strip()
        
        # b. Extract all vulnerability findings using the vulners script signature within the block
        # Pattern: (VULN_ID or CVE, EDB-ID, etc.) followed by a score and the vulners URL
        # We look for a reference ID and a score separated by space(s) right before vulners.com
        vuln_matches = re.findall(
            r'([A-Z]+-ID:\d+|CVE-\d{4}-\d+).*?\s+([\d.]+)\s+https://vulners.com/', 
            block, 
            re.IGNORECASE | re.DOTALL
        )
        
        if not vuln_matches:
            continue
            
        unique_vulnerabilities = {}
        
        for match in vuln_matches:
            try:
                # Match[0] is the ID (e.g., CVE-2023-1234), Match[1] is the score (e.g., 9.8)
                score = float(match[1])
                ref_id = match[0].strip()
                
                # Deduplicate based on the ID and prioritize the highest score if duplicate
                if ref_id not in unique_vulnerabilities or score > unique_vulnerabilities[ref_id]['Score']:
                    unique_vulnerabilities[ref_id] = {
                        'Port': port,
                        'Score': score,
                        'ID': ref_id,
                        'Service': full_service_info
                    }
            except ValueError:
                pass
        
        def get_status(score):
            if score >= 9.0: return 'CRITICAL'
            if score >= 7.0: return 'HIGH'
            if score >= 4.0: return 'MEDIUM'
            if score > 0.0: return 'LOW'
            return 'INFO'
            
        for ref_id, vuln in unique_vulnerabilities.items():
            vuln['Status'] = get_status(vuln['Score'])
            summaries.append(vuln)

    return summaries

def display_vuln_report(all_vulnerabilities: List[Dict], exploit_details: Dict[str, List[Dict]], full_output: str, is_searchsploit_available: bool) -> None:
    """Displays the final vulnerability and exploit report in two structured tables."""
    
    # --- Part 1: Consolidated Vulnerability Report (CVSS Score List) ---
    if all_vulnerabilities:
        print_colored("\n--- 1. CONSOLIDATED VULNERABILITY REPORT (CVSS Score List) ---", Colors.HEADER)
        
        # Sort by CVSS Score (highest first)
        all_vulnerabilities.sort(key=lambda x: x['Score'], reverse=True)
        
        print_colored(f"{'STATUS':<10} | {'CVSS SCORE':<12} | {'PORT':<10} | VULNERABILITY ID (SERVICE)", Colors.BOLD)
        draw_separator()
        
        for vuln in all_vulnerabilities:
            score_str = f"{vuln['Score']:.1f}"
            
            # Color coding based on status
            status_color = Colors.OKGREEN
            if vuln['Status'] == 'CRITICAL': status_color = Colors.FAIL
            elif vuln['Status'] == 'HIGH': status_color = Colors.WARNING
            elif vuln['Status'] == 'MEDIUM': status_color = Colors.OKBLUE
            elif vuln['Status'] == 'LOW': status_color = Colors.OKGREEN
            else: status_color = Colors.ENDC
            
            service_display = vuln.get('Service', 'N/A')[:35]
            
            print(f"{status_color}{vuln['Status']:<10}{Colors.ENDC} | {score_str:<12} | {vuln['Port']:<10} | {vuln['ID']} ({service_display})")

        draw_separator()
        print(f"[INFO] Total unique vulnerability findings: {len(all_vulnerabilities)}")
    else:
        print_colored("\n[INFO] Nmap 'vuln' scripts found no immediate vulnerabilities (CVSS score detected).", Colors.OKGREEN)

    # --- Part 2: Exploit Intelligence Report (Searchsploit Detailed List) ---
    if is_searchsploit_available:
        print_colored("\n--- 2. EXPLOIT INTELLIGENCE LOOKUP (Searchsploit Detailed List) ---", Colors.HEADER)
        
        found_any_exploit = False
        
        for port, exploits in exploit_details.items():
            if not exploits:
                continue
                
            # Check for error message
            if exploits[0].get("Title") and "Search Error" in exploits[0]["Title"]:
                print_colored(f"\n[PORT: {port:<7}] Error: {exploits[0]['Title']}", Colors.FAIL)
                continue
            
            found_any_exploit = True
            
            # Print Service Header
            print_colored(f"\n[PORT: {port}] Exploits Found ({len(exploits)} total):", Colors.OKBLUE)
            
            # Print table header for exploits
            print(f"{'TITLE (Exploit Name)':<70} | {'PATH/REFERENCE':<30}")
            draw_separator()
            
            for exploit in exploits:
                title = exploit['Title'][:69]
                path = exploit['Path'][:29]
                print(f"{Colors.FAIL}*{title:<69}{Colors.ENDC} | {path:<30}")
            
        if not found_any_exploit and not exploit_details:
             print_colored("\n[INFO] Searchsploit found no direct exploit payloads for identified services.", Colors.OKGREEN)
        
        draw_separator()
    else:
        print_colored("\n[WARNING] Searchsploit is not installed. Exploit Intelligence lookup skipped.", Colors.WARNING)

# =======================================================
# MODULE ENTRY POINT (run function)
# =======================================================

def run() -> None:
    """Perform vulnerability-focused scan and Exploit Intelligence lookup."""
    
    target = get_user_input("Enter target for Vulnerability Scan: ")
    if not target: return
    
    # Configuration Prompts
    port_range = get_user_input("Enter port range (e.g., 80,443 or 1-1000, default: ALL ports): ")
    if not port_range: port_range = "-p-" 

    timing_choice = get_user_input("Select timing template (T0-T5, default T3): ")
    if not timing_choice:
        timing_template = "-T3"
    elif timing_choice in ['0', '1', '2', '3', '4', '5']:
        timing_template = f"-T{timing_choice}"
    else:
        timing_template = "-T3"

    # Using the standard Nmap vulners and vuln script categories
    cmd = [
        "nmap", "-Pn", 
        "-sS", "-sV", "-O", 
        timing_template,
        "--script", "vuln,vulners", 
        port_range, 
        target
    ]
    
    print_colored("\n[INFO] Running Comprehensive Vulnerability Scan (NSE: vuln, vulners). Requires Root/sudo for best results.", Colors.OKBLUE)
    
    # Get output directory for saving raw results
    safe_target_name = target.replace('.', '_').replace('/', '_')
    out_dir = get_scan_output_dir(safe_target_name, "vulnscan")
    raw_out_path = os.path.join(out_dir, "vuln_raw.txt")
    
    # --- Execute the Scan ---
    is_searchsploit_available = check_searchsploit()

    try:
        res = run_command_with_output(cmd, timeout=1800) # 30 minutes timeout
        full_output = res['output']
        
    except Exception as e:
        print_colored(f"\n[CRITICAL ERROR] Scan execution failed: {e}", Colors.FAIL)
        return

    # --- Process and Report ---
    
    status = "completed" if res['returncode'] == 0 else f"failed (code {res['returncode']})"
    
    print("\n" + "=" * 60)
    print_colored(f"[{'âœ“' if res['returncode'] == 0 else 'âœ—'}] Vulnerability scan {status}.", Colors.OKGREEN if res['returncode'] == 0 else Colors.FAIL)
    print("=" * 60)

    if res['returncode'] == 0 and full_output:
        # Save raw output (DISABLED - per user request to not save)
        # try:
        #     with open(raw_out_path, "w", encoding="utf-8") as f: 
        #         f.write(full_output)
        #     print(f"[INFO] Full raw scan data saved to: {raw_out_path}")
        # except Exception as e:
        #     print_colored(f"[WARNING] Error saving raw output: {e}", Colors.WARNING)
            
        all_vulnerabilities = parse_vuln_output(full_output)
        
        # Get Exploit Intelligence Data
        service_versions = extract_service_versions(full_output)
        exploit_details = run_exploit_lookup(service_versions)
        
        # Display the report
        display_vuln_report(all_vulnerabilities, exploit_details, full_output, is_searchsploit_available)
    else:
        print("[INFO] Nmap did not produce usable output for parsing.")
    
    get_user_input("\nPress Enter to return to menu...")
